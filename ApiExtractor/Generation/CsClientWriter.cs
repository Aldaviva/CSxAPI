using ApiExtractor.Extraction;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ApiExtractor.Generation;

public static partial class CsClientWriter {

    private const string GeneratedDir  = @"..\..\..\..\CSxAPI\API\Generated";
    private const string Namespace     = "CSxAPI";
    private const string GeneratorName = "Aldaviva/CSxAPI";

    private static readonly string FileHeader = $"// File generated by {GeneratorName} on {DateTime.Now:U} UTC\r\n\r\n" +
        "#pragma warning disable 1591"; // documentation comments

    private static readonly UTF8Encoding Utf8               = new(false, true);
    private static readonly string       GeneratedAttribute = $"[GeneratedCode(\"{GeneratorName}\", null)]";

    private static int _methodsGenerated;
    private static int _eventsGenerated;
    private static int _enumsGenerated;
    private static int _apiCommandsGenerated;

    /// <summary>
    /// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
    /// </summary>
    private static readonly ISet<string> ReservedCsKeywords = new HashSet<string> {
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event",
        "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null",
        "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string",
        "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"
    };

    public static async Task WriteClient(ExtractedDocumentation documentation) {
        await writeConfiguration(documentation);
        Console.WriteLine("Generated xConfiguration client");

        await WriteCommands(documentation);
        Console.WriteLine("Generated xCommand client");

        await WriteStatuses(documentation);
        Console.WriteLine("Generated xStatus client");

        await WriteEvents(documentation);
        Console.WriteLine("Generated xEvent client");

        await WriteEnums(documentation);
        Console.WriteLine($"Generated {_enumsGenerated:N0} total enums");

        Console.WriteLine($"Generated {_methodsGenerated:N0} total methods");
        Console.WriteLine($"Generated {_eventsGenerated:N0} total events");
        Console.WriteLine($"Generated {_apiCommandsGenerated:N0} total API commands (xCommand, xConfiguration, xStatus, and xEvent)");
    }

    private static StreamWriter OpenFileStream(string filename) {
        string filePath = Path.Combine(GeneratedDir, filename);
        Directory.CreateDirectory(Path.GetDirectoryName(filePath)!);
        return new StreamWriter(new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.Read), Utf8);
    }

    private static IDictionary<string, ISet<INterfaceChild>> GenerateInterfaceTree<T>(IEnumerable<T> documentation) where T: IPathNamed {
        IDictionary<string, ISet<INterfaceChild>> interfaceTree = new Dictionary<string, ISet<INterfaceChild>>();

        foreach (T command in documentation) {
            string childInterfaceName = GetInterfaceName(command);
            PutInterfaceChild(childInterfaceName, new InterfaceMethod<T>(command));

            for (int length = command.NameWithoutBrackets.Count - 1; length > 1; length--) {
                string parentInterfaceName = GetInterfaceName(new DocXStatus { Name = command.NameWithoutBrackets.Take(length).ToList() });
                PutInterfaceChild(parentInterfaceName, new Subinterface<T>(childInterfaceName, command.NameWithoutBrackets[length - 1]));
                childInterfaceName = parentInterfaceName;
            }

            void PutInterfaceChild(string interfaceName, INterfaceChild child) {
                if (interfaceTree.TryGetValue(interfaceName, out ISet<INterfaceChild>? entry)) {
                    entry.Add(child);
                } else {
                    interfaceTree.Add(interfaceName, new HashSet<INterfaceChild> { child });
                }
            }
        }

        return interfaceTree;
    }

    private static string GetInterfaceName(IPathNamed method) {
        string singular = "I" + string.Join(null, method.NameWithoutBrackets.Skip(1)
            .SkipLast(1)
            .Append(method.NameWithoutBrackets[0][1..]));
        return singular + (singular.EndsWith('s') ? "es" : "s");
    }

    private static string GetArgumentName(Parameter param, bool forDocumentationXmlComment = false) {
        string name = param.Name.Replace(".", null);
        name = name == name.ToUpperInvariant() ? name.ToLowerInvariant() : name.ToLowerFirstLetter();

        if (!forDocumentationXmlComment && ReservedCsKeywords.Contains(name.ToLowerInvariant())) {
            name = "@" + name;
        }

        return name;
    }

}