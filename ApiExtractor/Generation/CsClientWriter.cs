using ApiExtractor.Extraction;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ApiExtractor.Generation;

public static partial class CsClientWriter {

    private const string GENERATED_DIR  = @"..\..\..\..\CSxAPI\API\Generated";
    private const string NAMESPACE      = "CSxAPI";
    private const string GENERATOR_NAME = "Aldaviva/CSxAPI";

    private static readonly string FILE_HEADER = $"// File generated by {GENERATOR_NAME} on {DateTime.Now:U} UTC\r\n\r\n" +
        "#pragma warning disable 1591"; // documentation comments

    private static readonly UTF8Encoding UTF8                = new(false, true);
    private static readonly string       GENERATED_ATTRIBUTE = $"[GeneratedCode(\"{GENERATOR_NAME}\", null)]";

    private static int methodsGenerated;
    private static int eventsGenerated;
    private static int enumsGenerated;
    private static int apiCommandsGenerated;

    /// <summary>
    /// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
    /// </summary>
    private static readonly ISet<string> RESERVED_CS_KEYWORDS = new HashSet<string> {
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event",
        "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null",
        "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string",
        "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"
    };

    public static async Task writeClient(ExtractedDocumentation documentation) {
        await writeConfiguration(documentation);
        Console.WriteLine("Generated xConfiguration client");

        await writeCommands(documentation);
        Console.WriteLine("Generated xCommand client");

        await writeStatuses(documentation);
        Console.WriteLine("Generated xStatus client");

        await writeEvents(documentation);
        Console.WriteLine("Generated xEvent client");

        await writeEnums(documentation);
        Console.WriteLine($"Generated {enumsGenerated:N0} total enums");

        Console.WriteLine($"Generated {methodsGenerated:N0} total methods");
        Console.WriteLine($"Generated {eventsGenerated:N0} total events");
        Console.WriteLine($"Generated {apiCommandsGenerated:N0} total API commands (xCommand, xConfiguration, xStatus, and xEvent)");
    }

    private static StreamWriter openFileStream(string filename) {
        string filePath = Path.Combine(GENERATED_DIR, filename);
        Directory.CreateDirectory(Path.GetDirectoryName(filePath)!);
        return new StreamWriter(new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.Read), UTF8);
    }

    private static IDictionary<string, ISet<InterfaceChild>> generateInterfaceTree<T>(IEnumerable<T> documentation) where T: IPathNamed {
        IDictionary<string, ISet<InterfaceChild>> interfaceTree = new Dictionary<string, ISet<InterfaceChild>>();

        foreach (T command in documentation) {
            string childInterfaceName = getInterfaceName(command);
            putInterfaceChild(childInterfaceName, new InterfaceMethod<T>(command));

            for (int length = command.nameWithoutBrackets.Count - 1; length > 1; length--) {
                string parentInterfaceName = getInterfaceName(new DocXStatus { name = command.nameWithoutBrackets.Take(length).ToList() });
                putInterfaceChild(parentInterfaceName, new Subinterface<T>(childInterfaceName, command.nameWithoutBrackets[length - 1]));
                childInterfaceName = parentInterfaceName;
            }

            void putInterfaceChild(string interfaceName, InterfaceChild child) {
                if (interfaceTree.TryGetValue(interfaceName, out ISet<InterfaceChild>? entry)) {
                    entry.Add(child);
                } else {
                    interfaceTree.Add(interfaceName, new HashSet<InterfaceChild> { child });
                }
            }
        }

        return interfaceTree;
    }

    private static string getInterfaceName(IPathNamed method) {
        string singular = "I" + string.Join(null, method.nameWithoutBrackets.Skip(1)
            .SkipLast(1)
            .Append(method.nameWithoutBrackets[0][1..]));
        return singular + (singular.EndsWith('s') ? "es" : "s");
    }

    private static string getArgumentName(Parameter param, bool forDocumentationXmlComment = false) {
        string name = param.name.Replace(".", null);
        name = name == name.ToUpperInvariant() ? name.ToLowerInvariant() : name.ToLowerFirstLetter();

        if (!forDocumentationXmlComment && RESERVED_CS_KEYWORDS.Contains(name.ToLowerInvariant())) {
            name = "@" + name;
        }

        return name;
    }

}